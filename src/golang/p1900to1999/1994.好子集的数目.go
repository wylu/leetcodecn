package p1900to1999

/*
 * @lc app=leetcode.cn id=1994 lang=golang
 *
 * [1994] 好子集的数目
 *
 * https://leetcode-cn.com/problems/the-number-of-good-subsets/description/
 *
 * algorithms
 * Hard (56.31%)
 * Likes:    103
 * Dislikes: 0
 * Total Accepted:    10.9K
 * Total Submissions: 19.3K
 * Testcase Example:  '[1,2,3,4]'
 *
 * 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集
 * 。
 *
 *
 * 比方说，如果 nums = [1, 2, 3, 4] ：
 *
 *
 * [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
 * [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
 *
 *
 *
 *
 * 请你返回 nums 中不同的 好 子集的数目对 10^9 + 7 取余 的结果。
 *
 * nums 中的 子集 是通过删除 nums
 * 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,2,3,4]
 * 输出：6
 * 解释：好子集为：
 * - [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
 * - [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
 * - [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
 * - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
 * - [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
 * - [3]：乘积为 3 ，可以表示为质数 3 的乘积。
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [4,2,3,15]
 * 输出：5
 * 解释：好子集为：
 * - [2]：乘积为 2 ，可以表示为质数 2 的乘积。
 * - [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
 * - [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
 * - [3]：乘积为 3 ，可以表示为质数 3 的乘积。
 * - [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 10^5
 * 1 <= nums[i] <= 30
 *
 *
 */

/**
 * @File    :   1994.好子集的数目.go
 * @Time    :   2022/02/22 21:40:38
 * @Author  :   wylu
 * @Version :   1.0
 * @Contact :   15wylu@gmail.com
 * @License :   Copyright © 2020, wylu-CHINA-SHENZHEN. All rights reserved.
 * @Desc    :
 * 方法一：状态压缩动态规划
 * 思路与算法
 *
 * 注意到题目规定数组 nums 中的元素不超过 30，因此我们可以将 [1, 30] 中的整数分成
 * 如下三类：
 *
 *   - 1：对于任意一个好子集而言，我们添加任意数目的 1，得到的新子集仍然是好子集；
 *   - 2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30：这些数均不包含平方因子，
 *     因此每个数在好子集中至多出现一次；
 *   - 4,8,9,12,16,18,20,24,25,27,28：这些数包含平方因子，因此一定不能在好子集中出现。
 *
 * 我们可以通过硬编码的方式把 [1, 30] 中的整数按照上述分类，也可以先预处理出所有
 * [1, 30] 中质数 2,3,5,7,11,13,17,19,23,29，再通过试除的方式动态分类。
 *
 * 分类完成后，我们就可以考虑动态规划了。由于每个质因数只能出现一次，并且 [1, 30]
 * 中一共有 10 个质数，因此我们可以用一个长度为 10 的二进制数 mask 表示这些质因数
 * 的使用情况，其中 mask 的第 i 位为 1 当且仅当第 i 个质数已经被使用过。
 *
 * 这样一来，我们定义 f[i][mask] 表示当我们只选择 [2, i] 范围内的数，并且选择的数
 * 的质因数使用情况为 mask 时的方案数。如果 i 本身包含平方因子，那么我们无法选择 i，
 * 相当于在 [2, i-1] 范围内选择，状态转移方程为：
 *
 *   f[i][mask] = f[i-1][mask]
 *
 * 如果 i 本身不包含平方因子，记其包含的质因子的二进制表示为 subset（同样可以通过
 * 试除的方法得到），那么状态转移方程为：
 *
 *   f[i][mask] = f[i - 1][mask] + f[i-1][mask \ subset] * freq[i]
 *
 * 其中：
 *
 *   - freq[i] 表示数组 nums 中 i 出现的次数；
 *   - mask \ subset 表示从二进制表示 mask 中去除所有在 subset 中出现的 1，
 *     可以使用按位异或运算实现。这里需要保证 subset 是 mask 的子集，可以使用
 * 	   按位与运算来判断。
 *
 * 动态规划的边界条件为：
 *
 *   f[1][0] = 2^freq[1]
 *
 * 即每一个在数组 nums 中出现的 1 都可以选或不选。
 *
 * 最终的答案即为所有 f[30][..] 中除了 f[30][0] 以外的项的总和。
 *
 * 细节
 *
 * 注意到 f[i][mask] 只会从 f[i-1][..] 转移而来，并且 f[i-1][..] 中的下标总是小于
 * mask，因此我们可以使用类似 0-1 背包的空间优化方法，在遍历 mask 时从 2^10 - 1
 * 到 1 逆序遍历，这样就只需要使用一个长度为 2^10 的一维数组做状态转移了。
 */

// @lc code=start
func numberOfGoodSubsets(nums []int) int {
	const mod int = 1e9 + 7
	primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}
	freq := [31]int{}
	for _, num := range nums {
		freq[num]++
	}

	f := make([]int, 1<<len(primes))
	f[0] = 1
	for i := 0; i < freq[1]; i++ {
		f[0] = f[0] * 2 % mod
	}

next:
	for i := 2; i < 31; i++ {
		if freq[i] == 0 {
			continue
		}

		// 检查 i 的每个质因数是否均不超过 1 个
		subset := 0
		for j, prime := range primes {
			if i%(prime*prime) == 0 {
				continue next
			}
			if i%prime == 0 {
				subset |= 1 << j
			}
		}

		// 动态规划
		for mask := 1 << len(primes); mask > 0; mask-- {
			if mask&subset == subset {
				f[mask] = (f[mask] + f[mask^subset]*freq[i]) % mod
			}
		}
	}

	ans := 0
	for _, v := range f[1:] {
		ans = (ans + v) % mod
	}

	return ans
}

// @lc code=end
