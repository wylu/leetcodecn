package p600to699

/*
 * @lc app=leetcode.cn id=629 lang=golang
 *
 * [629] K个逆序对数组
 *
 * https://leetcode-cn.com/problems/k-inverse-pairs-array/description/
 *
 * algorithms
 * Hard (49.46%)
 * Likes:    151
 * Dislikes: 0
 * Total Accepted:    9.6K
 * Total Submissions: 19.5K
 * Testcase Example:  '3\n0'
 *
 * 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。
 *
 * 逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。
 *
 * 由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值。
 *
 * 示例 1:
 *
 *
 * 输入: n = 3, k = 0
 * 输出: 1
 * 解释:
 * 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
 *
 *
 * 示例 2:
 *
 *
 * 输入: n = 3, k = 1
 * 输出: 2
 * 解释:
 * 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
 *
 *
 * 说明:
 *
 *
 * n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。
 *
 *
 */

/**
 * @File    :   629.k个逆序对数组.go
 * @Time    :   2021/11/11 13:50:09
 * @Author  :   wylu
 * @Version :   1.0
 * @Contact :   15wylu@gmail.com
 * @License :   Copyright © 2020, wylu-CHINA-SHENZHEN. All rights reserved.
 * @Desc    :
 * 方法一：动态规划
 * 思路与算法
 *
 * 我们可以用动态规划的方法来解决本题。
 *
 * 设 f[i][j] 表示我们使用数字 1, 2, ..., i 的排列构成长度为 i 的数组，并且恰好
 * 包含 j 个逆序对的方案数。在进行状态转移时，我们可以考虑第 i 个元素选取了
 * 1, 2, ..., i 中的哪个数字。
 *
 * 假设我们选取了数字 k，那么数组的前 i-1 个元素由 1, ..., k-1 以及 k+1, ..., i
 * 的某个排列构成。数组中的逆序对的个数可以看成如下的两部分之和：
 *
 * - 数字 k 与前 i-1 个元素产生的逆序对的个数；
 * - 前 i-1 个元素「内部」产生的逆序对个数。
 *
 * 对于第一部分而言，我们可以求出：数字 k 会贡献 i-k 个逆序对，即 k+1, ..., i
 * 与 k 分别产生一个逆序对。
 *
 * 对于第二部分而言，我们希望它能够有 j - (i-k) 个逆序对，这样才能一共有 j 个
 * 逆序对。由于我们关心的是前 i-1 个元素「内部」产生的逆序对个数，而逆序对只和
 * 元素的「相对大小」有关，因此我们可以：
 *
 * - 1, ..., k-1 这些元素保持不变；
 * - k+1, ..., i 这些元素均减少 1，变成 k, ..., i-1。
 *
 * 使得前 i-1 个元素中，任意两个元素的相对大小都不发生变化。此时，我们的目标
 * 变成了「对于 1, 2, ..., i-1 希望它能够有 j-(i-k) 个逆序对」，这就是动态
 * 规划中的子任务 f[i-1][j-(i-k)]。
 *
 * 因此，我们就可以通过枚举 k 得到状态转移方程：
 *
 * f[i][j] = sum{k=1,i} f[i-1][j-(i-k)] = sum{k=0,i-1} f[i-1][j-k]
 *
 * 边界条件为：
 *
 * - f[0][0] = 1，即不用任何数字可以构成一个空数组，它包含 0 个逆序对；
 * - f[i][j<0] = 0，由于逆序对的数量一定是非负整数，因此所有 j < 0 的状态
 *   的值都为 0。我们不需要显式地存储这些状态，只需要在进行状态转移遇到这样
 *   的项时，注意特殊判断即可。
 *
 * 最终的答案即为 f[n][k]。
 *
 * 优化
 *
 * 上述动态规划的状态数量为 O(nk)，而求出每一个 f[i][j] 需要 O(n) 的时间
 * 复杂度，因此总时间复杂度为 O(n^2 * k)，会超出时间限制，我们必须要进行优化。
 *
 * 我们考虑 f[i][j-1] 和 f[i][j] 的状态转移方程：
 *
 * - f[i][j-1] = sum{k=0,i-1} f[i-1][j-1-k]
 * - f[i][j] = sum{k=0,i-1} f[i-1][j-k]
 *
 * 可以得到从 f[i][j-1] 到 f[i][j] 的递推式：
 *
 * f[i][j] = f[i][j-1] - f[i-1][j-i] + f[i-1][j]
 *
 * 这样我们就可以在 O(1) 的时间计算出每个 f[i][j]，总时间复杂度降低为 O(nk)。
 *
 * 此外，由于 f[i][j] 只会从第 f[i-1][..] 和 f[i][..] 转移而来，因此我们
 * 可以对动态规划使用的空间进行优化，即使用两个一维数组交替地进行状态转移，
 * 空间复杂度从 O(nk) 降低为 O(k)。
 *
 * 方法二：动态规划
 * 解题思路
 * 不妨按照 1 到 N 的顺序依次添加数字。在添加数字 i 的时候，最多可以形成 i-1
 * 个新的逆序对（将 i 放在最前面），最少则是不形成新的逆序对（将 i 放在最后面）。
 *
 * 令 dp[i][j] 表示添加到数字 i 时，一共形成 j 个逆序对的方法数，由上面的分析，
 * 不难看出
 *
 * 	dp[i][j] = sum{k=0,i-1} dp[i-1][j-k]
 *
 * 直接按照这一转移方程进行计算的复杂度将达到 O(N^2 * K)，无法在时限内完成。
 * 但注意到这里的求和部分是连续项求和，并且，在计算 dp[i] 时，所有的 dp[i-1]
 * 应该都已经计算完成，那么我们就可以在计算完 dp[i-1] 后，求出其对应的前缀和，
 * 从而就能够以 O(1) 的时间计算出任意的 dp[i][j]。
 *
 * 进一步的，因为 dp[i] 完全取决于 dp[i-1]，我们可以将动态规划的数组压缩为一维。
 */

// @lc code=start
func kInversePairs(n int, k int) int {
	MOD := 1000000007
	pre := make([]int, k+2)
	cur := make([]int, k+2)

	max := func(x, y int) int {
		if x > y {
			return x
		}
		return y
	}

	for i := 1; i <= n; i++ {
		cur[1] = 1

		for j := 2; j <= k+1; j++ {
			cur[j] = (pre[j] - pre[max(0, j-i)] + MOD) % MOD
		}

		for j := 1; j <= k+1; j++ {
			pre[j] = (pre[j-1] + cur[j]) % MOD
		}
	}

	return cur[k+1]
}

// @lc code=end

// func kInversePairs(n int, k int) int {
// 	MOD := 1000000007
// 	f := [2][]int{make([]int, k+1), make([]int, k+1)}
// 	f[0][0] = 1

// 	for i := 1; i <= n; i++ {
// 		for j := 0; j <= k; j++ {
// 			cur := i & 1
// 			pre := cur ^ 1
// 			f[cur][j] = f[pre][j]
// 			if j > 0 {
// 				f[cur][j] += f[cur][j-1]
// 			}
// 			if j >= i {
// 				f[cur][j] -= f[pre][j-i]
// 			}

// 			if f[cur][j] >= MOD {
// 				f[cur][j] -= MOD
// 			} else if f[cur][j] < 0 {
// 				f[cur][j] += MOD
// 			}
// 		}
// 	}

// 	return f[n&1][k]
// }
